#!/usr/bin/env nu

let XDG_STATE_HOME = (
  $env
  | get --optional XDG_STATE_HOME
  | default $"($env.HOME)/.local/state"
)
let STATE_DIR = $"($XDG_STATE_HOME)/tw"
let TEMPLATE_FILE = "template.toml"
let TEMPLATE_FILE_PATH = $"($STATE_DIR)/($TEMPLATE_FILE)"

# Taskwarrior wrapper that adds my own custom functionality
def main [
  ...args: string       # args to pass directly to `task`
] {
  ^task ...$args
}

# Add a task
def "main add" [...args: string] {
  let now = date now | date to-timezone UTC
  let template = (get-template $now)
  if ($template.add.expire > $now) {
    ^task add ...$template.add.args ...$args
  } else {
    ^task add ...$args
  }
}

# Interactively edit task notes with your $EDITOR
def "main notes" [
  task: string      # Task ID
] {
  edit $task "notes"
}

# Define a parameter template to include in all `add` commands
def "main template add" [
  --ttl(-t) = 10min   # how long the template should remain in effect
  --clear(-c)         # clear the current template
  ...args: string     # the `task` parameters you want to add to the template
] {
  if $clear {
    rm --force $TEMPLATE_FILE_PATH
    return
  }

  let now = date now | date to-timezone UTC
  let config = (
    get-template $now
    | update add.expire ($now + $ttl)
    | if ($args | length) > 0 {
      update add.args $args
    } else {
      # no args were specified. leave the existing config args (if any) alone, and just
      # update the ttl.
      $in
    }
  )
  mkdir $STATE_DIR
  $config | save --force $TEMPLATE_FILE_PATH
  ignore
}

# Interactively edit task attributes with your $EDITOR
def edit [
  task: string       # Task ID
  attribute: string  # Name of the attribute to edit
] {
  let temp_dir = mktemp --directory
  let cleanup = {
    cd -;
    rm --recursive --force $temp_dir;
  }
  cd $temp_dir

  try {
    safe-exec [task _get $"($task).($attribute)"] | save attribute.md
    ^$env.EDITOR attribute.md
    safe-exec [task $task modify $"($attribute):(open attribute.md | str trim)"]
  } catch {|err|
    do $cleanup
    error make $err
  }

  do $cleanup
}

def safe-exec [$args: list<string>]: nothing -> string {
  do { ^$args }
  | complete
  | match $in {
    {exit_code: 0} => { $in.stdout }
    {exit_code: $x} => {
      let result = $in
      error make {
        msg: $"Exited with code ($x): ($args | str join ' ')\n\n($result | table)"
      }
    }
  }
}

def get-template [now: datetime]: nothing -> record {
  if ($TEMPLATE_FILE_PATH | path exists) {
    let raw_template = open $TEMPLATE_FILE_PATH
    # convert expiration string to a datetime
    $raw_template | update add.expire ($raw_template.add.expire | into datetime)
  } else {
    {
      add: {
        expire: $now
        args: []
      }
    }
  }
}

def not-implemented []: nothing -> record {
  { msg: "Work in progress. Not implemented yet." }
}
