#!/usr/bin/env nu

let XDG_STATE_HOME = (
  $env
  | get --optional XDG_STATE_HOME
  | default $"($env.HOME)/.local/state"
)
let STATE_DIR = $"($XDG_STATE_HOME)/tw"
let TEMPLATE_FILE = "template.toml"
let TEMPLATE_FILE_PATH = $"($STATE_DIR)/($TEMPLATE_FILE)"

# Taskwarrior wrapper that adds my own custom functionality
def main [
  ...args: string       # args to pass directly to `task`
] {
  ^task ...$args
}

# Add a task
def "main add" [...args: string] {
  let now = date now | date to-timezone UTC
  let template = (get-template $now)
  if ($template.add.expire > $now) {
    ^task add ...$template.add.args ...$args
  } else {
    ^task add ...$args
  }
}

# Interactively edit task notes with your `$EDITOR`
def "main notes" [
  task: string      # Task ID
] {
  edit $task "notes"
}

# Define a parameter template to include in all `add` commands
def "main template add" [
  --ttl(-t) = 10min   # how long the template should remain in effect
  --clear(-c)         # clear the current template
  ...args: string     # the `task` parameters you want to add to the template
] {
  if $clear {
    rm --force $TEMPLATE_FILE_PATH
    return
  }

  let now = date now | date to-timezone UTC
  let config = (
    get-template $now
    | update add.expire ($now + $ttl)
    | if ($args | length) > 0 {
      update add.args $args
    } else {
      # no args were specified. leave the existing config args (if any) alone, and just
      # update the ttl.
      $in
    }
  )
  mkdir $STATE_DIR
  $config | save --force $TEMPLATE_FILE_PATH
  ignore
}

# Taskwarrior sync, with optional `vdirsyncer` and `pueue` integration
def "main sync" [...args: string]: nothing -> nothing {
  let tw_sync_id = enqueue-cmd --group tw-sync --parallel 2 task sync ...$args
  let cal_sync_id = if (which vdirsyncer | is-not-empty) {
    enqueue-cmd --group tw-sync --parallel 2 vdirsyncer sync
  } else {
    null
  }

  let sync_job_ids = (
    [$tw_sync_id $cal_sync_id] | where { $in != null }
  )

  if ($sync_job_ids | is-not-empty) {
    $"Sync jobs enqueued: run `pueue log ($sync_job_ids | str join ' ')` for details." | print
  }
}

# Interactively edit task attributes with your `$EDITOR`
def edit [
  task: string       # Task ID
  attribute: string  # Name of the attribute to edit
] {
  let temp_dir = mktemp --directory
  let cleanup = {
    cd -;
    rm --recursive --force $temp_dir;
  }
  cd $temp_dir

  try {
    safe-exec [task _get $"($task).($attribute)"] | save attribute.md
    ^$env.EDITOR attribute.md
    safe-exec [task $task modify $"($attribute):(open attribute.md | str trim)"]
  } catch {|err|
    do $cleanup
    error make $err
  }

  do $cleanup
}

def safe-exec [$args: list<string>]: nothing -> string {
  do { ^$args }
  | complete
  | match $in {
    {exit_code: 0} => { $in.stdout }
    {exit_code: $x} => {
      let result = $in
      error make {
        msg: $"Exited with code ($x): ($args | str join ' ')\n\n($result | table)"
      }
    }
  }
}

def get-template [now: datetime]: nothing -> record {
  if ($TEMPLATE_FILE_PATH | path exists) {
    let raw_template = open $TEMPLATE_FILE_PATH
    # convert expiration string to a datetime
    $raw_template | update add.expire ($raw_template.add.expire | into datetime)
  } else {
    {
      add: {
        expire: $now
        args: []
      }
    }
  }
}

# Enqueue a command with `pueue`, if installed. If not, just run the command.
def enqueue-cmd [
  --group: string
  --parallel: int = 1
  --wait
  ...args: string
]: nothing -> int {

  if (which pueue | is-empty) {
    # Pueue not installed. Just run the command directly.
    if  ($args | is-not-empty) {
      ^$args | print
    }
    return null
  }

  let group_exists = (
    ^pueue group --json
    | from json
    | columns
    | find $group
    | is-not-empty
  )
  if (not $group_exists) {
    ^pueue group add --parallel $parallel $group
  }

  let task_id = if ($args | is-not-empty) {
    ^pueue add --group $group --print-task-id -- ...$args | into int
  } else {
    null
  }

  if $wait {
    ^pueue wait --group $group
  }

  $task_id
}

def not-implemented []: nothing -> record {
  { msg: "Work in progress. Not implemented yet." }
}
