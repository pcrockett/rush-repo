#!/usr/bin/env -S nu --stdin

const BASE_URL = "https://kagi.com/api/v0"

# Kagi CLI
def main [] {
  "ERROR: Must specify a subcommand.\n" | print
  exec $env.CURRENT_FILE "--help"
}

# Set your Kagi API token
def "main set-token" [] {
  let token = (input --suppress-output "Paste your API token here and press enter to continue.")
  $token | save --force (token_path)
}

# Search Kagi (opens your browser)
def "main search" [
  query?: string  # Search query
  --stdin         # Read query from stdin
  --write         # open text editor to get query
] {
  let query = (
    if $stdin { $in }
    else if $write { long_form_input }
    else { $query }
  )
  match $query {
    null | "" => { browser open "https://kagi.com" }
    $q => { browser open $"https://kagi.com/search?q=($q | url encode)" }
  }
}

# Query FastGPT
def "main gpt" [
  query?: string  # Query to send to FastGPT
  --verbose(-v)   # Display meta information at the end
] {

  let query = if $query == null {
    $in
  } else {
    $query
  }

  # <https://help.kagi.com/kagi/api/fastgpt.html#examples>
  let response = (
    api_post fastgpt {
      query: $query
      cache: true
    }
  )

  let data = $response.data

  print $data.output

  if ($data | get references --optional | length) > 0 {
    print "References:\n"
    $data.references | enumerate | each {|it|
      print $"($it.index + 1). [($it.item.title)]\(($it.item.url))"
    }
  }

  if $verbose {
    print ""
    print "---"
    print ""
    print $"* **Tokens used:** _($data.tokens)_"
    print $"* **API balance:** _$($response.meta.api_balance)_"
  }

  ignore
}

# Summarize a URL
def "main summarize" [
  url: string             # URL to summarize
  --type(-t) = "summary"  # `summary` or `takeaway`
  --engine(-e) = "cecil"  # Engine to use. `cecil`, `agnes`, `daphne`, `muriel`
  --language(-l): string  # Output language (two-letter code)
  --verbose(-v)           # Verbose output at end
] {
  def get_params [] {
    let api_params = {
      url: $url
      engine: $engine  # https://help.kagi.com/kagi/api/summarizer.html#summarization-engines
      summary_type: $type
    }

    if ($language != null) and (($language | str length) > 0) {
      # https://help.kagi.com/kagi/api/summarizer.html#target-language-codes
      $api_params | insert target_language $language
    } else {
      $api_params
    }
  }

  let response = (
    api_post summarize (get_params)
  )

  let data = $response.data

  print $data.output

  if $verbose {
    let meta = $response.meta
    print ""
    print "---"
    print ""
    print $"* **Tokens used:** _($data.tokens)_"
    print $"* **Time:** _($meta.ms)_"
    print $"* **API balance:** _$($meta.api_balance)_"
  }

  ignore
}

# Use Kagi Assistant (opens your browser)
def "main assist" [
  query?: string     # set your initial query
  --profile: string  # choose a non-default model
  --no-internet      # disable internet access
  --lens: string     # select a lens if internet access enabled
  --stdin            # read query from stdin
  --write:           # open $EDITOR to write your query
] {
  let query = (
    if $stdin { $in }
    else if $write { long_form_input }
    else { $query }
  )

  # <https://help.kagi.com/kagi/ai/assistant.html#url-parameters>
  let query_params = (
    {
      internet: (if $no_internet { "false" } else { "true" })
    }
    | insert-if { $profile | is-not-empty } "profile" $profile
    | insert-if { $lens | is-not-empty } "lens" $lens
    | insert-if { $query | is-not-empty } "q" $query
  )
  let query_string = $query_params | url build-query
  browser open $"https://kagi.com/assistant/?($query_string)"
}

def insert-if [condition: closure, field: string, new_value: any] {
  let obj = $in
  if (do $condition) {
    $obj | insert $field $new_value
  } else {
    $obj
  }
}

def api_post [endpoint: string, data: record] {
  let token_path = (token_path)
  let token = match ($token_path | path exists) {
    true => { open $token_path --raw | decode "utf-8" | str trim }
    false => {
      error make {
        msg: "API Token has not been set yet. Run `kagi set-token`."
      }
    }
  }

  (
    http post
      --content-type "application/json"
      --headers ["Authorization" $"Bot ($token)"]
      $"($BASE_URL)/($endpoint)"
      $data
  )
}

def token_path [] {
  let config_home = match ($env | get --optional XDG_CONFIG_HOME) {
    null => { $env.HOME | path join ".config/kagi-cli" }
    $val => { $val | path join "kagi-cli" }
  }
  mkdir $config_home
  $config_home | path join "token"
}

def "browser open" [$url: string] {
  let open_cmd = (
    $env
    | get --optional KAGI_OPEN_COMMAND
    | if ($in | is-empty) {
      "xdg-open"
    } else {
      $in
    }
  )

  strict_exec [$open_cmd $url]
}

# open your $EDITOR to a temp file, and return the contents of that temp file when
# editor is closed
def long_form_input [] {
  let editor = (
    $env
    | get --optional EDITOR
    | if ($in | is-empty) {
      error make { msg: "Must specify $EDITOR env variable." }
    } else {
      $in
    }
  )
  let temp_dir = strict_exec [mktemp --directory]
  let cleanup = { rm --recursive --force $temp_dir }
  let result = try {
    let temp_file = $temp_dir | path join "input.md"
    ^$editor $temp_file
    (
      $temp_file
      | if ($in | path exists) {
        open $in | str trim
      } else {
        error make { msg: "Aborted" }
      }
    )
  } catch { |err|
    do $cleanup
    error make { msg: $err.msg }
  }

  do $cleanup
  if ($result | is-empty) {
    error make { msg: "Aborted due to empty input" }
  } else {
    $result
  }
}

def strict_exec [$command: list<string>] {
  ^$command
  | complete
  | match $in {
    {exit_code: 0} => { $in.stdout | str trim }
    {exit_code: $x} => {
      error make { msg: $"($command) exited with code ($x)" }
    }
  }
}
