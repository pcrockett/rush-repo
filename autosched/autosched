#!/usr/bin/env nu

# Bulk-schedule taskwarrior tasks within a time window
def main [
  begin_timestamp: string      # the beginning of your time window
  duration: string             # how long your time window will last
  ...filter_args: string       # additional taskwarrior filter args
  --default-duration = "30min" # duration to use if task has none
  --commit                     # don't just show changes; make them
] {
  # Nushell's parsing of CLI arguments is not quite the same as when you do it
  # explicitly. Ex: Defaulting to UTC datetimes instead of local. So we opt to keep some
  # of our arguments plain strings and manually parse instead:
  let begin_time = match $begin_timestamp {
    "now" => { date now }
    $val => { $val | into datetime }
  }
  let window_duration = $duration | into duration
  let default_duration = $default_duration | into duration

  let tasks = (
    ^task -BLOCKED status:pending ...$filter_args export
    | from json
    | each {|t|
      merge {
        urgency: ($t.urgency | math round --precision 1)
        duration: ($t | get-duration $default_duration)
        schedule: null  # reset task scheduled time if it already exists
      }
    }
    | sort-tasks
  )

  let tasks = (
    $tasks | schedule-tasks {begin: $begin_time, duration: $window_duration}
  )

  if ($commit) {
    (
      $tasks
      | each {
        let sched = ($in.schedule | default "")
        ^task $in.uuid modify $"schedule:($sched)"
      }
    )
  } else {
    $"
Would schedule:

(
  $tasks
  | select id description schedule duration urgency impact
  | table --expand --index false
)
Add `--commit` if you want to make these changes.
" | print
  }
}

# retrieve the `duration` UDA of a task and parse it.
# if the UDA isn't defined, a default will be chosen.
def get-duration [default: duration]: record -> duration {
  get --optional duration | default $default | into duration
}

def sort-tasks []: list<record> -> list<record> {
  let fields_to_sort_by = [
    { name: urgency  order: desc }
    { name: impact   order: desc }
    { name: duration order: desc }
    { name: uuid     order: asc  }
  ]
  $in | sort-by --custom {|a,b|
    let first_nonequal_field = (
      $fields_to_sort_by
      | each {|f|
        merge {
          a_val: ($a | get --optional $f.name)
          b_val: ($b | get --optional $f.name)
        }
      }
      | where { $in.a_val != $in.b_val }
      | first
    )
    if $first_nonequal_field.order == desc {
      $first_nonequal_field.a_val > $first_nonequal_field.b_val
    } else {
      $first_nonequal_field.a_val < $first_nonequal_field.b_val
    }
  }
}

def schedule-tasks [
  time_window: record<begin: datetime, duration: duration>
]: list<record> -> list<record> {
  let original_tasks = $in
  if ($original_tasks | length) == 0 {
    return $original_tasks
  }

  let new_state = (
    $original_tasks | schedule-first $time_window
  )

  if $new_state.has_changes {
    (
      $new_state.scheduled
      | append (
        $new_state.unscheduled | schedule-tasks $new_state.time_window
      )
    )
  } else {
    (
      $new_state.scheduled | append $new_state.unscheduled
    )
  }
}

def schedule-first [
  time_window: record<begin: datetime, duration: duration>
]: list<record> -> record<has_changes: bool, scheduled: list<record>, unscheduled: list<record>, time_window: record<begin: datetime, duration: duration>> {
  let original_tasks = $in
  let unscheduled = $original_tasks | where { is-empty schedule }
  let scheduled = $original_tasks | where { is-not-empty schedule }
  if (($unscheduled | length) == 0) or ($time_window.duration <= 0min) {
    return {
      has_changes: false
      scheduled: $scheduled
      unscheduled: $unscheduled
      time_window: $time_window
    }
  }

  let to_schedule = (
    $unscheduled | where {|t| $t.duration <= $time_window.duration } | first
  )
  if ($to_schedule | is-empty) {
    return {
      has_changes: false
      scheduled: $scheduled
      unscheduled: $unscheduled
      time_window: $time_window
    }
  } else {
    let formatted_time = $time_window.begin | format date "%Y-%m-%dT%H:%M"
    let updated_task = $to_schedule | update schedule $formatted_time
    let updated_window = {
      begin: ($time_window.begin + $updated_task.duration)
      duration: ($time_window.duration - $updated_task.duration)
    }
    return {
      has_changes: true
      scheduled: ($scheduled | append $updated_task)
      unscheduled: ($unscheduled | where { $in.uuid != $to_schedule.uuid })
      time_window: $updated_window
    }
  }
}
